{
  // 服务监听地址
  "listen": ":8080",

  // 反代后端地址
  "backend": "https://api.siliconflow.cn/",

  // 每个代理最多绑定 auth key 数量（建议 1-5）
  "max_auth_per_proxy": 1,

  // 单次请求最多尝试几个代理（失败自动切换下一个可用代理）
  "max_request_retries": 3,

  // 带 key 的转发请求“连接预算”（包含选路 + 通过代理建立到后端的连接/TLS 握手，包含重试消耗），默认 10s
  // 一旦连上后端并开始返回内容（尤其是 SSE/流式），不会再因为这个超时而被中断；只会随客户端断开而结束。
  "request_timeout": "10s",

  "redis": {
    "addr": "redis:6379",
    "password": "",
    "db": 0
  },

  "sources": [
    {
      "type": "url",
      "url": "https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/socks5.txt",
      "interval": "3h",
      // max_live_proxies:
      //   -1: 仅在出现 no available proxy for auth 时触发拉取（不会按 interval 定时拉取；但仍受 interval 冷却限制）
      //    0: 按 interval 一直拉取
      //   >0: 按 interval 拉取，但当存活代理数 >= max_live_proxies 时跳过
      "max_live_proxies": 0,
      // true: 用正则匹配 ip:port（with_prefix=true 时匹配 socks5://ip:port）；false: 逐行按 host:port 解析
      "use_regex": true,
      // true 表示每行是 socks5://ip:port；false 表示每行 ip:port
      "with_prefix": false
    }
  ],

  "health_check": {
    "interval": "60s",
    "timeout": "5s",
    // 探活目标：backend 表示直接探测反代后端；也可以写成 host:port
    "target": "backend",
    // 连续 dead 达到 3 次直接剔除
    "max_failures": 3,
    // 被剔除（Remove）后的代理会进入冷却期，避免马上被重新抓取/加入；到期后允许再次加入
    "dead_proxy_ttl": "24h",
    "concurrency": 2048
  },

  "pool": {
    "max_idle_conns": 200,
    "max_idle_conns_per_host": 100,
    "idle_timeout": "90s"
  }
}